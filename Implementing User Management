The tool you’re building is going to be running on Linux systems and it’s safe to assume that it’s going to run via sudo. With this information it’s safe to say that the tool can utilize usermod, useradd, and userdel to keep users on the server up to date.

Create a module in your package to work with user information. You’ll want to be able to do the following:

Received a list of user dictionaries and ensure that the system’s users match.
Have a function that can create a user with the given information if no user exists by that name.
Have a function that can update a user based on a user dictionary.
Have a function that can remove a user with a given username.
The create, update, and remove functions should print that they are creating/updating/removing the user before executing the command.
The user information will come in the form of a dictionary shaped like this:

{
  'name': 'kevin',
  'groups': ['wheel', 'dev'],
  'password': '$6$HXdlMJqcV8LZ1DIF$LCXVxmaI/ySqNtLI6b64LszjM0V5AfD.ABaUcf4j9aJWse2t3Jr2AoB1zZxUfCr8SOG0XiMODVj2ajcQbZ4H4/'
}
The password values will be SHA512 encrypted.

Hint: You can generate an encrypted password in Python that is usable with usermod -p with this snippet:

import crypt

crypt.crypt('password', crypt.mksalt(crypt.METHOD_SHA512))
Tools to Consider:
You’ll likely want to interface with the following unix utilities:

useradd
usermod
userdel
Python modules you’ll want to research:

pwd - Password/User database.
grp - Group database.
Be careful in testing not to delete your own user or change your password to something that you don’t know.


Here’s an example of how you could implement this module. These are the tests that I used to drive my implementation:

tests/test_users.py

import pytest
import subprocess

from hr import users

# encrypted version of 'password'
password = '$6$HXdlMJqcV8LZ1DIF$LCXVxmaI/ySqNtLI6b64LszjM0V5AfD.ABaUcf4j9aJWse2t3Jr2AoB1zZxUfCr8SOG0XiMODVj2ajcQbZ4H4/'

user_dict = {
    'name': 'kevin',
    'groups': ['wheel', 'dev'],
    'password': password
}

def test_users_add(mocker):
    """
    Given a user dictionary. `users.add(...)` should
    utilize `useradd` to create a user with the password
    and groups.
    """
    mocker.patch('subprocess.call')
    users.add(user_dict)
    subprocess.call.assert_called_with([
        'useradd',
        '-p',
        password,
        '-G',
        'wheel,dev',
        'kevin',
    ])

def test_users_remove(mocker):
    """
    Given a user dictionary, `users.remove(...)` should
    utilize `userdel` to delete the user.
    """
    mocker.patch('subprocess.call')
    users.remove(user_dict)
    subprocess.call.assert_called_with([
        'userdel',
        '-r',
        'kevin',
    ])

def test_users_update(mocker):
    """
    Given a user dictionary, `users.update(...)` should
    utilize `usermod` to set the groups and password for the
    user.
    """
    mocker.patch('subprocess.call')
    users.update(user_dict)
    subprocess.call.assert_called_with([
        'usermod',
        '-p',
        password,
        '-G',
        'wheel,dev',
        'kevin',
    ])

def test_users_sync(mocker):
    """
    Given a list of user dictionaries, `users.sync(...)` should
    create missing users, remove extra non-system users, and update
    existing users. A list of existing usernames can be passed in
    or default users will be used.
    """
    existing_user_names = ['kevin', 'bob']
    users_info = [
        user_dict,
        {
            'name': 'jose',
            'groups': ['wheel'],
            'password': password
        }
    ]
    mocker.patch('subprocess.call')
    users.sync(users_info, existing_user_names)

    subprocess.call.assert_has_calls([
        mocker.call([
            'usermod',
            '-p',
            password,
            '-G',
            'wheel,dev',
            'kevin',
        ]),
        mocker.call([
            'useradd',
            '-p',
            password,
            '-G',
            'wheel',
            'jose',
        ]),
        mocker.call([
            'userdel',
            '-r',
            'bob',
        ]),
    ])
Notice: Since there were multiple calls made to subprocess.call within the sync test we used a different assertion method called assert_has_calls which takes a list of mocker.call objects. The mocker.call method wraps the content we would otherwise have put in an assert_called_with assertion.

Here is my implementation of this module (with a few helper functions prefixed with underscores):

src/hr/users.py

import pwd
import string
import subprocess
import sys

def add(user_info):
    print("Adding user '%s'" % user_info['name'])
    try:
        subprocess.call([
            'useradd',
            '-p',
            user_info['password'],
            '-G',
            _groups_str(user_info),
            user_info['name'],
        ])
    except:
        print("Failed to add user '%s'" % user_info['name'])
        sys.exit(1)

def remove(user_info):
    print("Removing user '%s'" % user_info['name'])
    try:
        subprocess.call([
            'userdel',
            '-r',
            user_info['name']
        ])
    except:
        print("Failed to remove user '%s'" % user_info['name'])
        sys.exit(1)

def update(user_info):
    print("Updating user '%s'" % user_info['name'])
    try:
        subprocess.call([
            'usermod',
            '-p',
            user_info['password'],
            '-G',
            _groups_str(user_info),
            user_info['name'],
        ])
    except:
        print("Failed to update user '%s'" % user_info['name'])
        sys.exit(1)

def sync(users, existing_user_names=None):
    existing_user_names = (existing_user_names or _user_names())
    user_names = [user['name'] for user in users]
    for user in users:
        if user['name'] not in existing_user_names:
            add(user)
        elif user['name'] in existing_user_names:
            update(user)
    for user_name in existing_user_names:
        if not user_name in user_names:
            remove({ 'name': user_name })

def _groups_str(user_info):
    return string.join(user_info['groups'] or [], ',')

def _user_names():
    return [user.pw_name for user in pwd.getpwall()
            if user.pw_uid >= 1000 and 'home' in user.pw_dir]
I utilized the pwd module to get a list of all of the users on the system and determined which ones weren’t system users by looking for UIDs over 999 and ensuring that the user’s directory was under home. Additionally, the string module was used to combine a list of strings into a single string separated by ,s by using the join function. The join function is roughly equivalent to:

index = 0
group_str = ""
for group in groups:
    if index == 0:
        group_str += group
    else:
        group_str += ",%s" % group
    index+=1
To manually test this you’ll need to (temporarily) run the following from within your project’s directory:

sudo pip install -e .
Then you will be able to run the following to be able to use your module in a REPL without getting permissions errors for calling out to usermod, userdel, and useradd:

sudo python
>>> from hr import users
